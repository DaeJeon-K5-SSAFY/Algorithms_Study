## BOJ_17472_다리만들기

---

<br />

### 코드

```java

```

<br />


### 결과 :ACK

- 메모리 : KB
- 실행시간 : ms
- 코드길이 : B

<br />

### 풀이 방법
모든 섬을 연결하는 다리 길이의 최솟값을 출력한다. 모든 섬을 연결하는 것이 불가능하면 -1을 출력한다. 

2차원 배열에서 중복되는 경로를 최소경로로 가지게 되는 경우

완탐, 크루스칼

완탐으로 진행하게 되면 1번에서 최소였던 경로를 2번 정점에서 변경할 수 있는 로직이 필요하다. 결국 크루스칼 알고리즘으로 변경될 것

```
크루스칼 알고리즘 (Kruskal) + 서로소 집합

서로소 집합을 위한 makeSet, findSet, unionSet을 제작

p 배열에 각 정점이 가리키는 부모 노드 (루트 노드)가 저장된다.

makeset()
    for i -> V
        p[i] = i; // 자기 자신

findset(a)
    if(p[a] == a) return a;
    return p[a] = findset(p[a]); // a 자신의 루트 노드를 찾으러간다. (short path -> 경로 단축)

unionSet(a, b)
    a = findset(a);
    b = findset(b);
    if(a == b) return false; // 이미 합집합이 된 정점
    p[b] = a;
    return true;

다리만들기 1을 참고해서 

2차원 배열에서 섬으로부터 최소 거리를 구하기 -> 섬 : V, 거리 : E

BFS를 통해서 섬의 id를 지정해준다. 

지정된 섬 구획으로부터 가장 최소의 거리를 찾는다.
각 정점으로부터 최소 거리를 가지게 될 것.

정점 from, to 최소 거리를 간선으로 Egde 클래스 리스트를 완성하자.

for i 
    for j 
        getEdge(i,j) // 시작 위치를 가지고 최소 위치와 최소 정점을 알아야 함.
        id에 따라서 

getEdge(i, j, from){
    if visit from -> 이미 간선 정보를 추출했다면 다음 섬으로 넘어가도록

    
}

```

<br />

<!--추가 내용 있다면 더 적어주시면 됩니다-->

---
