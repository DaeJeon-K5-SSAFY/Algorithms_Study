## BoJ_문제번호_문제이름

---

<br />

### 코드

```java
package com.ssafy.problem2;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class BOJ_14503_로봇청소기 {
//	static class Robot{
//		int x,y,d;
//		public Robot(int y, int x, int d) {
//			this.y = y;
//			this.x = x;
//			this.d = d;
//		}
//	}
	public static void main(String[] args) {
		try {
			version1();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	static int[][] del = {{-1, 0},{0, 1}, {1, 0}, {0, -1}}; // 북 동 남 서
	static int cleanCnt = 0;
	static int N, M;
	private static void version1() throws IOException {
		System.setIn(new FileInputStream("data2/14503.txt"));
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer stk = new StringTokenizer(br.readLine());
		N = Integer.parseInt(stk.nextToken());
		M = Integer.parseInt(stk.nextToken());
		
		stk = new StringTokenizer(br.readLine());
		int r = Integer.parseInt(stk.nextToken()); 
		int c = Integer.parseInt(stk.nextToken());
		int d = Integer.parseInt(stk.nextToken());
//		Robot robot = new Robot(Integer.parseInt(stk.nextToken()), Integer.parseInt(stk.nextToken()), Integer.parseInt(stk.nextToken()));
		
		int[][] map = new int[N][];
		for(int i = 0; i < N; i++) {
			map[i] = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray(); 
		}
		dfs(r, c, d, map);
		System.out.println(cleanCnt);
		br.close();
	}
	static boolean endFlag = false;
	private static void dfs(int r, int c, int d, int[][] map) {
		if(map[r][c] == 0) {
			map[r][c] = 2; 
			cleanCnt++;
		}
		
		int dy,dx,dd;
		int cd = d;
		boolean state = false;
		for(int i = 0; i < 4; i++) {
			dd = (cd + 3 - i) % 4;    
			dy = r + del[dd][0];
			dx = c + del[dd][1];
			if(map[dy][dx] == 0) {
				dfs(dy, dx, dd, map);
				state = true;
				break;
			}
		}
		if(!state) {
			dy = r + del[(d + 2) % 4][0];
			dx = c + del[(d + 2) % 4][1];
			if(map[dy][dx] != 1)  // 벽이 아니라서 후진할 수 있음
				dfs(dy, dx, d, map);
		}
	}
}
```

<br />


### 결과 : 맞았습니다.

- 메모리 : 18940KB
- 실행시간 : 232ms
- 코드길이 : - B

<br />

### 풀이 방법
BOJ_14503_로봇청소기

특징
- 이동 알고리즘이 주어짐 (그에 맞게 구현)
- DFS, 재귀 호출로 구현
- 기저조건
  - 4방향이 벽이거나 청소했을 때는 바라보는 방향의 후진을 한다. 만약 뒤쪽이 벽이라면 청소 끝

패턴
- 방위 변환에 사용되는 delta (북동남서, 시계방향)
- 왼쪽 방향을 항상 봐야 한다.
  - delta = dir + 3 - i % 4 // 현재 방향에서 왼쪽 방향으로 돌면서 볼 때
  - 뒤쪽 방향 delta = (d + 2) % 4 

<br />

<!--추가 내용 있다면 더 적어주시면 됩니다-->
!!! note
    처음에 Robot 객체를 쥐어주고 r,c,d 형식으로 진행해보려고 했는데, DFS를 구현하게 되면 이전 메서드에 대한 변수값들이 필요하다. 근데 Robot 객체로 구현하면 r,c,d는 유지되기 때문에 이를 수정해주는 작업이 필요하다. 그러므로 지역 변수를 사용해서 DFS를 적용하는 것이 좋다. 
---
