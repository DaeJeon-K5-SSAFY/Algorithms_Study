## BOJ_15686_치킨배달

---

<br />

### 코드

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.StringTokenizer;

class Loc{
	int x;
	int y;
	int dist;
	
	public Loc(int x, int y) {
		this.x = x;
		this.y = y;
	}
}

public class BOJ_15686_치킨배달 {
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	
	public static void main(String[] args) {
		try {
//			version1();
			version2();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	static List<Integer> chickenList = new ArrayList<>();
	private static void version2() throws IOException {
		// 입력단
		System.setIn(new FileInputStream("data/15686.txt"));
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		StringTokenizer stk = new StringTokenizer(br.readLine());
		
		int N = Integer.parseInt(stk.nextToken());
		int M = Integer.parseInt(stk.nextToken());
		int[][] chickenMap = new int[N][N];
		
		List<Loc> house = new ArrayList<>();
		List<Loc> chicken = new ArrayList<>();
		
		int temp = 0;
		for(int i = 0; i < N; i++) {
			stk = new StringTokenizer(br.readLine());
			for(int j = 0; j < N; j++) {
				temp = Integer.parseInt(stk.nextToken());
				if(temp == 1) house.add(new Loc(j, i));
				if(temp == 2) chicken.add(new Loc(j, i));
				chickenMap[i][j] = temp;
			}
		}
		
		subset(chicken.size(), M);  // N, M 
		// 치킨 거리 알고리즘
		int closeDist = Integer.MAX_VALUE;
		for(int i = 0; i < chickenList.size(); i++) { // 조합 개수만큼 반복하며 치킨집 위치 판단
			int f = chickenList.get(i);
			int subClose = 0;
			for(int j = 0; j < house.size(); j++) { // 집으로 부터 가장 가까운 치킨집을 찾기
				int minVal = Integer.MAX_VALUE;	
				for(int k = 0; k < chicken.size(); k++) { 
					if((f & 1<<k) != 0) { // 치킨집이 존재하는 곳에서 치킨 거리 구하기
						minVal = Math.min(minVal, 
								Math.abs(house.get(j).x - chicken.get(k).x) + 
								Math.abs(house.get(j).y - chicken.get(k).y));
					}
				}
				subClose += minVal;
			}
			closeDist = Math.min(closeDist, subClose);
		}
		bw.write(String.valueOf(closeDist));
		bw.close();
		br.close();
	}

	private static void subset(int n, int m) {
		for(int i = 0; i < 1<<n; i++) {
			int cnt = 0 ;
			for(int j = 0; j < n; j++) {
				if((i & 1<<j) != 0) cnt++;
			}
			int flag = 0;
			if(cnt < 1 || m < cnt) continue;
			for(int j = 0; j < n; j++) {
				if((i & 1<<j) != 0)
					flag |= 1<<j; 
			}
			chickenList.add(flag);
		}
	}
}
```

<br />

### 결과 : 맞았습니다.

- 메모리 : 14720 KB
- 실행시간 : 208 ms
- 코드길이 : - B

<br />

### 풀이 방법
BOJ_15686_치킨배달

특징
- 최대 M개수의 치킨집을 구하여라 -> 부분집합으로 구하되 1~m개까지 치킨집을 선택한 경우를 구해야함 **(중요)**
- 치킨 거리 구하기는 식 |r~1~-r~2~| + |c~1~-c~2~|
- 선택된 조합을 가지고 도시의 치킨 거리를 구하기

패턴
- 포인트는 **최대 M개수**의 치킨집의 조합 경우를 구하는 것이다.         
  - 1 ~ m개일 때의 조합 경우를 다 얻어서 진행
  - bitmasking을 이용하여서 굳이 배열을 사용하지 않고도 int flag 하나만 사용해서 구할 수 있다.

<br />

<!--추가 내용 있다면 더 적어주시면 됩니다-->

---
